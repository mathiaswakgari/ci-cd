from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_socketio import SocketIO, emit
from flask_login import LoginManager, UserMixin, login_user, current_user, login_required
from bson import ObjectId
from datetime import datetime
from cryptography.fernet import Fernet
from dotenv import dotenv_values
import pymongo
import bcrypt
import rsa
import base64

# --- Load env vars ---
config = dotenv_values(".env")
fernet_key = config["FERNET_SECRET_KEY"].encode()
fernet = Fernet(fernet_key)

# --- Flask setup ---
app = Flask(__name__)
CORS(app, origins="http://localhost:5173", supports_credentials=True)
socketio = SocketIO(app, cors_allowed_origins="http://localhost:5173")
app.secret_key = 'your_secret_key'

# --- MongoDB setup ---
client = pymongo.MongoClient(
    "mongodb+srv://dagim99demis:joEdkawXIjb15t2i@cluster0.diuya0h.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0")
db = client['secure_messaging']
users_collection = db['users']
messages_collection = db['messages']

# --- Flask-Login setup ---
login_manager = LoginManager()
login_manager.init_app(app)

# --- Global server RSA keys ---
(public_key, private_key) = rsa.newkeys(2048)


class User(UserMixin):
    def __init__(self, user_id):
        self.id = user_id


@login_manager.user_loader
def load_user(user_id):
    user = users_collection.find_one({"_id": ObjectId(user_id)})
    if user:
        return User(str(user["_id"]))
    return None


@app.route('/public-key', methods=['GET'])
def get_public_key():
    return jsonify({'public_key': public_key.save_pkcs1().decode()})


@app.route('/register', methods=['POST'])
def register():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    gender = data.get('gender')

    if users_collection.find_one({"username": username}):
        return jsonify({"error": "Username already exists"}), 400

    # Generate a unique avatar URL based on gender and username
    avatar_base = "https://avatar.iran.liara.run/public"
    avatar = f"{avatar_base}/boy/{username}" if gender == "male" else f"{avatar_base}/girl/{username}"

    hashed_password = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
    user_pub_key, user_priv_key = rsa.newkeys(2048)
    encrypted_private_key = fernet.encrypt(user_priv_key.save_pkcs1())

    user_data = {
        "username": username,
        "password": hashed_password,
        "public_key": user_pub_key.save_pkcs1().decode(),
        "private_key": encrypted_private_key.decode(),
        "gender": gender,
        "avatar": avatar  # Unique avatar URL
    }

    user_id = users_collection.insert_one(user_data).inserted_id
    return jsonify({"message": "Registered", "user_id": str(user_id)})


@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username, password = data.get('username'), data.get('password')
    user = users_collection.find_one({"username": username})

    if not user or not bcrypt.checkpw(password.encode(), user["password"]):
        return jsonify({"error": "Invalid credentials"}), 400

    login_user(User(str(user["_id"])))
    return jsonify({"message": "Login successful", "user_id": str(user["_id"])})


@app.route('/users', methods=['GET'])
@login_required
def get_users():
    all_users = users_collection.find({}, {"username": 1, "avatar": 1})

    user_list = []
    for user in all_users:
        if str(user["_id"]) != str(current_user.id):  # Ensure string comparison
            user_list.append({
                "_id": str(user["_id"]),
                "username": user["username"],
                # Safe fallback if avatar is missing
                "image": user.get("avatar", "")
            })

    return jsonify(user_list)


@app.route('/messages/<recipient_id>', methods=['GET'])
@login_required
def get_conversation(recipient_id):
    messages = messages_collection.find({
        "$or": [
            {"sender_id": current_user.id, "recipient_id": recipient_id},
            {"sender_id": recipient_id, "recipient_id": current_user.id}
        ]
    }).sort("timestamp", 1)

    return jsonify([
        {
            "sender_id": msg["sender_id"],
            "recipient_id": msg["recipient_id"],
            "message": msg["message"],
            "timestamp": msg["timestamp"]
        } for msg in messages
    ])


@socketio.on('send_message')
def handle_send_message(data):
    encrypted_b64 = data.get("message")
    recipient_id = data.get("recipient_id")

    if not encrypted_b64 or not recipient_id:
        emit("error", {"error": "Missing fields"})
        return

    try:
        encrypted_bytes = base64.b64decode(encrypted_b64.encode())
        user = users_collection.find_one({"_id": ObjectId(current_user.id)})
        encrypted_private_key_b64 = user['private_key'].encode()
        decrypted_private_key = fernet.decrypt(encrypted_private_key_b64)
        private_key = rsa.PrivateKey.load_pkcs1(decrypted_private_key)

        decrypted_message = rsa.decrypt(encrypted_bytes, private_key).decode()

        # Store in DB
        messages_collection.insert_one({
            "sender_id": current_user.id,
            "recipient_id": recipient_id,
            "message": decrypted_message,
            "timestamp": datetime.now()
        })

        emit("receive_message", {
            "sender_id": current_user.id,
            "recipient_id": recipient_id,
            "message": decrypted_message
        }, broadcast=True)

    except Exception as e:
        print("‚ùå Error:", e)
        emit("error", {"error": "Decryption failed"})


if __name__ == "__main__":
    socketio.run(app, host="0.0.0.0", port=5000, debug=True)
